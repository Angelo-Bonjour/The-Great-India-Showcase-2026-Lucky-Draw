
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>THE GREAT INDIA SHOWCASE 2026 - LUCKY DRAW</title>

<!-- Canvas Confetti -->
<script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"></script>
<!-- Papa Parse for robust CSV parsing (handles quotes/commas) -->
<script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>

<style>
  :root {
    --bg: #002f61;
    --gift-base: #f4d67a;       /* light golden */
    --gift-shade: #e9c85a;      /* slightly darker golden */
    --lid-base: #f6d97f;        /* lid light gold */
    --lid-shade: #e6c45a;       /* lid darker */
    --ribbon: #d62828;          /* deep red for bow only */
    --ribbon-dark: #a71e1e;
    --gold: #ffcc00;
    --text: #ffffff;
  }
  * { box-sizing: border-box; }
  body {
    margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    background: var(--bg); color: var(--text); min-height: 100vh;
    display: flex; flex-direction: column; align-items: center; gap: 16px;
  }
  header { text-align: center; margin-top: 18px; }
  h1 { margin: 0 0 8px; letter-spacing: 0.5px; }
  .sub { opacity: .85; font-size: .95rem; }

  /* Controls */
  #controls { display: flex; flex-wrap: wrap; gap: 10px; justify-content: center; }
  button, .chip {
    cursor: pointer; border: none; border-radius: 8px; padding: 10px 14px; font-weight: 600;
    background: var(--gold); color: #111; box-shadow: 0 2px 0 rgba(0,0,0,.15);
  }
  button:disabled { opacity: .6; cursor: not-allowed; }
  .chip { background: rgba(255,255,255,.15); color: #fff; border: 1px solid rgba(255,255,255,.25); }
  .chip input { vertical-align: middle; margin-right: 6px; }

  /* Stage & Gift */
  .stage { width: min(92vw, 860px); display: grid; place-items: center; }
  .gift {
    width: min(92vw, 780px); height: min(68vh, 480px); position: relative;
    display: grid; place-items: center; perspective: 900px; margin-top: 8px;
  }

  /* Box base (no ribbons on base, per request) */
  .box-base {
    position: absolute; inset: 120px 0 0 0; /* leaves space for closed lid area */
    margin: auto; width: 100%; height: calc(100% - 120px);
    background: linear-gradient(145deg, var(--gift-base) 0%, var(--gift-shade) 100%);
    border-radius: 14px; border: 4px solid #fff; overflow: hidden;
    box-shadow: 0 16px 40px rgba(0,0,0,.35), inset 0 0 0 2px rgba(255,255,255,.25);
    z-index: 1;
  }

  /* Lid (has a vertical ribbon strip on top only) */
  .lid {
    position: absolute; width: calc(100% + 16px); height: 110px; left: 50%; transform: translateX(-50%);
    top: 18px; border-radius: 12px; border: 4px solid #fff; z-index: 5;
    background: linear-gradient(145deg, var(--lid-base) 0%, var(--lid-shade) 100%);
    box-shadow: 0 10px 20px rgba(0,0,0,.35);
    transform-origin: center bottom;
  }
  .lid::after {
    content: ""; position: absolute; left: 50%; top: 0; width: 56px; height: 100%; transform: translateX(-50%);
    background: linear-gradient(90deg, var(--ribbon) 0%, var(--ribbon-dark) 100%);
  }

  /* Bow on top (tied ribbon) */
  .bow {
    position: absolute; top: -4px; left: 50%; transform: translateX(-50%); z-index: 6;
    width: 150px; height: 68px; pointer-events: none;
  }
  .bow .loop { position: absolute; width: 72px; height: 56px; border-radius: 50% 50% 45% 45%;
    background: radial-gradient(circle at 30% 30%, #ff6b6b, var(--ribbon-dark));
    box-shadow: inset 0 0 8px rgba(0,0,0,.25); }
  .bow .loop.left { left: 0; transform: rotate(-12deg); }
  .bow .loop.right { right: 0; transform: rotate(12deg); }
  .bow .knot { position: absolute; left: 50%; top: 18px; transform: translateX(-50%);
    width: 36px; height: 30px; border-radius: 10px; background: linear-gradient(145deg, #ff4b4b, var(--ribbon-dark));
    box-shadow: inset 0 0 6px rgba(0,0,0,.25); }

  /* Lid animation (triggered AFTER countdown now) */
  .lid-fly { animation: flyOff 1.1s ease-out forwards; }
  @keyframes flyOff {
    0% { transform: translate(-50%, 0) rotate(0); }
    60% { transform: translate(calc(-50% - 80px), -160px) rotate(-18deg); }
    100% { transform: translate(calc(-50% - 140px), -260px) rotate(-28deg); opacity: .9; }
  }

  /* Entries grid (kept safely below the lid area) */
  .box-content {
    position: absolute; inset: 140px 16px 16px 16px; /* clearly below lid */
    display: grid; grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
    gap: 10px; align-content: start; overflow: hidden; scrollbar-width: thin; z-index: 2;
  }
  .entry {
    background: rgba(0,0,0,.08); border: 1px solid rgba(255,255,255,.35);
    padding: 10px; border-radius: 10px; text-align: center; font-size: .95rem;
    animation: slowBlink 1.5s infinite; /* faster blink */
    transition: transform .12s ease, left .35s ease, top .35s ease;
    color: #1b1b1b; font-weight: 600;
  }
  .entry .name { font-weight: 800; display: block; color: #000; }
  .entry .company { font-size: .85rem; opacity: .9; color: #222; }
  @keyframes slowBlink { 0%,100% {opacity:1} 50% {opacity:.5} }

  /* Free-move mode during draw phase */
  .free .entry { position: absolute; width: 180px; }

  /* Overlay */
  #overlay { position: fixed; inset: 0; display: none; place-items: center; background: rgba(0,0,0,.35); z-index: 50; text-align: center; backdrop-filter: blur(1px); }
  #overlay .count { font-size: clamp(64px, 12vw, 140px); font-weight: 800; text-shadow: 0 6px 0 rgba(0,0,0,.3); }
  #overlay .label { margin-top: 6px; font-size: 1.1rem; opacity: .9; }

  /* Winners */
  #winners { width: min(92vw, 860px); background: rgba(255,255,255,.1); padding: 14px; border-radius: 12px; }
  #winners h2 { margin: 0 0 10px; }
  #winnerList { margin: 6px 0 0; padding-left: 18px; }
  #status { min-height: 20px; opacity: .95; font-size: .92rem; }

  .note { font-size: .86rem; opacity: .85; }
</style>
</head>
<body>
  <header>
    <h1>Grand Lucky Draw</h1>
    <div class="sub">Google Sheet CSV â†’ Columns: <strong>Full Name</strong> and <strong>Name of Company</strong></div>
  </header>

  <div id="controls">
    <button id="btnRefresh">Refresh Participant List</button>
    <label class="chip"><input type="checkbox" id="autoRefresh"> Auto-Refresh (10s)</label>
    <button id="btnStart">Start Draw</button>
    <button id="btnSound">Enable Sound</button>
  </div>

  <div class="stage">
    <div class="gift" aria-label="Gift Box">
      <div class="lid" id="lid"></div>
      <div class="bow" aria-hidden="true">
        <div class="loop left"></div>
        <div class="loop right"></div>
        <div class="knot"></div>
      </div>
      <div class="box-base" aria-hidden="true"></div>
      <div id="entries" class="box-content">Loading participantsâ€¦</div>
    </div>
  </div>

  <section id="winners">
    <div id="status"></div>
    <h2>Past Winners</h2>
    <ul id="winnerList"></ul>
    <button id="btnReset">Reset Draw</button>
    <div class="note">Tip: You can also pass a CSV URL by appending <code>?csv=ENCODED_URL</code> to the page URL.</div>
  </section>

  <!-- Overlay for countdown / drawing state -->
  <div id="overlay">
    <div>
      <div class="count" id="countText"></div>
      <div class="label" id="phaseLabel"></div>
    </div>
  </div>

  <!-- Sounds (explicit files for drum & pop) -->
  <audio id="drum" preload="auto" src="https://www.soundjay.com/human/sounds/drum-roll-01.mp3"></audio>
  <audio id="pop" preload="auto" src="https://www.soundjay.com/buttons/sounds/button-16.mp3"></audio>

<script>
(function(){
  // ---- Config ----
  const DEFAULT_SHEET_CSV = "https://docs.google.com/spreadsheets/d/e/2PACX-1vR9EzQVA4kCkKxyzpQ2S61wrHce8ohaH7v_QvgPzfLqNMkghG3O-_JGYQBVcUmE0-Y-vsKio3pnTeh5/pub?output=csv";
  const DRAW_COUNTDOWN_SEC = 3;
  const DRAW_PHASE_MS = 5000;
  const AUTO_REFRESH_MS = 10000;

  // ---- State ----
  let participants = []; // ["Full Name (Company)", ...]
  let activePool = [];
  let winners = [];
  let autoTimer = null;
  let drawing = false;
  let moveTimer = null;

  // ---- Elements ----
  const entriesEl = document.getElementById('entries');
  const lidEl = document.getElementById('lid');
  const overlayEl = document.getElementById('overlay');
  const countText = document.getElementById('countText');
  const phaseLabel = document.getElementById('phaseLabel');
  const statusEl = document.getElementById('status');

  const btnRefresh = document.getElementById('btnRefresh');
  const btnStart = document.getElementById('btnStart');
  const btnReset = document.getElementById('btnReset');
  const chkAuto = document.getElementById('autoRefresh');
  const btnSound = document.getElementById('btnSound');

  const drum = document.getElementById('drum');
  const pop = document.getElementById('pop');
  drum.volume = 0.9; pop.volume = 0.7;

  // ---- Utils ----
  function getCsvUrl(){
    const urlParam = new URLSearchParams(location.search).get('csv');
    let url = urlParam ? decodeURIComponent(urlParam) : DEFAULT_SHEET_CSV;
    const marker = 'output=csv';
    const idx = url.indexOf(marker);
    if (idx !== -1) url = url.slice(0, idx + marker.length);
    return url;
  }

  function setStatus(msg, isError=false){
    statusEl.textContent = msg || '';
    statusEl.style.color = isError ? '#ffd2d2' : '#ffffff';
  }

  function disableControls(disabled){
    btnStart.disabled = disabled; btnRefresh.disabled = disabled; btnReset.disabled = disabled; chkAuto.disabled = disabled; btnSound.disabled = disabled;
  }

  function renderEntries(){
    if (!activePool.length){ entriesEl.textContent = 'No participants available.'; return; }
    const html = activePool.map(p => {
      const m = p.match(/^(.*) \((.*)\)$/); // Full Name (Company)
      const name = m ? m[1] : p; const company = m ? m[2] : '';
      return `<div class="entry"><span class="name">${escapeHtml(name)}</span><span class="company">${escapeHtml(company)}</span></div>`;
    }).join('');
    entriesEl.innerHTML = html;
  }

  function escapeHtml(s){ return String(s).replace(/[&<>"]/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;'}[c])); }

  // ---- CSV Fetch & Parse ----
  async function refreshParticipants(){
    try {
      setStatus('Fetching participantsâ€¦');
      const url = getCsvUrl();
      const res = await fetch(url, { cache: 'no-store' });
      if (!res.ok) throw new Error('Network error: ' + res.status);
      const csvText = await res.text();
      const parsed = Papa.parse(csvText, { header: true, skipEmptyLines: true });
      if (parsed.errors && parsed.errors.length){ console.warn(parsed.errors); }

      const rows = parsed.data;
      const toKey = s => String(s||'').trim().toLowerCase();
      const mapped = rows.map(r => {
        const o = {}; Object.keys(r).forEach(k => { o[toKey(k)] = r[k]; });
        const full = (o['full name'] || o['fullname'] || o['name'] || '').toString().trim();
        const comp = (o['name of company'] || o['company'] || '').toString().trim();
        return { full, comp };
      }).filter(x => x.full && x.comp);

      participants = mapped.map(x => `${x.full} (${x.comp})`);
      const seen = new Set();
      participants = participants.filter(p => (seen.has(p) ? false : (seen.add(p), true)));

      activePool = participants.filter(p => !winners.includes(p));
      renderEntries();
      setStatus(`Loaded ${participants.length} participants. Active pool: ${activePool.length}.`);
    } catch (err){
      console.error(err);
      setStatus('Failed to fetch/parse CSV. Ensure it\'s published as CSV and column titles are "Full Name" and "Name of Company".', true);
      entriesEl.textContent = 'Unable to load participants.';
    }
  }

  // ---- Auto refresh ----
  function toggleAuto(){
    if (chkAuto.checked){
      autoTimer = setInterval(refreshParticipants, AUTO_REFRESH_MS);
    } else {
      clearInterval(autoTimer); autoTimer = null;
    }
  }

  // ---- Countdown ----
  function countdown(sec){
    overlayEl.style.display = 'grid';
    phaseLabel.textContent = 'Get Readyâ€¦';
    return new Promise(resolve => {
      let cur = sec;
      countText.textContent = cur;
      const timer = setInterval(()=>{
        cur -= 1; countText.textContent = cur > 0 ? cur : 'Go!';
        if (cur <= 0){ clearInterval(timer); setTimeout(resolve, 600); }
      }, 1000);
    });
  }

  // ---- Free movement logic ----
  function startFreeMove(){
    entriesEl.classList.add('free');
    const bounds = entriesEl.getBoundingClientRect();
    const items = Array.from(entriesEl.children);
    // Initial random placement
    items.forEach(el => {
      const {w, h} = getItemSize(el);
      const pos = randomPosition(bounds, w, h);
      el.style.left = pos.x + 'px';
      el.style.top  = pos.y + 'px';
    });
    moveTimer = setInterval(()=>{
      const b = entriesEl.getBoundingClientRect();
      items.forEach(el => {
        const {w, h} = getItemSize(el);
        const pos = randomPosition(b, w, h);
        const rot = (Math.random()*10 - 5);
        const scale = 1 + (Math.random()*0.08);
        el.style.left = pos.x + 'px';
        el.style.top  = pos.y + 'px';
        el.style.transform = `rotate(${rot}deg) scale(${scale})`;
      });
    }, 380);
  }

  function getItemSize(el){
    // Approximate; fall back to 180x66 if not laid out
    const r = el.getBoundingClientRect();
    const w = r.width || 180; const h = r.height || 66; return {w, h};
  }

  function randomPosition(containerRect, w, h){
    const pad = 6;
    const maxX = Math.max(0, containerRect.width - w - pad);
    const maxY = Math.max(0, containerRect.height - h - pad);
    const x = Math.floor(Math.random() * maxX) + pad/2;
    const y = Math.floor(Math.random() * maxY) + pad/2;
    return {x, y};
  }

  function stopFreeMove(){
    clearInterval(moveTimer); moveTimer = null;
    entriesEl.classList.remove('free');
    // Clear inline left/top/transform so grid layout returns
    Array.from(entriesEl.children).forEach(el => { el.style.left=''; el.style.top=''; el.style.transform='none'; });
  }

  // ---- Draw logic ----
  async function startDraw(){
    if (drawing) return; if (!activePool.length){ alert('No participants left!'); return; }
    drawing = true; disableControls(true);

    await countdown(DRAW_COUNTDOWN_SEC);

    // Open the lid AFTER countdown
    lidEl.classList.remove('lid-fly'); void lidEl.offsetWidth; // reflow
    lidEl.classList.add('lid-fly');

    // Start drum roll and movement
    try { drum.currentTime = 0; await drum.play(); } catch(e) { console.warn('Drum blocked:', e); }
    phaseLabel.textContent = 'Drawingâ€¦'; countText.textContent = '';

    // Switch entries to free-move mode
    startFreeMove();

    await new Promise(r => setTimeout(r, DRAW_PHASE_MS));

    stopFreeMove();

    // Pick winner (unique)
    const winner = activePool[Math.floor(Math.random()*activePool.length)];
    winners.push(winner);
    activePool = activePool.filter(p => p !== winner);

    // Confetti + pop sound
    burstConfetti();
    try { pop.currentTime = 0; await pop.play(); } catch(e) { console.warn('Pop blocked:', e); }

    overlayEl.style.display = 'grid';
    countText.textContent = 'ðŸŽ‰';
    phaseLabel.textContent = 'Winner!\n' + winner;
    setTimeout(()=> overlayEl.style.display = 'none', 2000);

    renderEntries();
    renderWinners();

    setStatus(`Winner: ${winner}. Remaining in pool: ${activePool.length}.`);
    disableControls(false); drawing = false;
  }

  function burstConfetti(){
    const end = Date.now() + 600;
    (function frame(){
      confetti({ particleCount: 100, spread: 70, startVelocity: 55, origin: { y: 0.7 } });
      if (Date.now() < end) requestAnimationFrame(frame);
    })();
    confetti({ particleCount: 180, angle: 60, spread: 60, origin: { x: 0 }, zIndex: 200 });
    confetti({ particleCount: 180, angle: 120, spread: 60, origin: { x: 1 }, zIndex: 200 });
  }

  function renderWinners(){
    const ul = document.getElementById('winnerList');
    ul.innerHTML = winners.map(w => `<li>${escapeHtml(w)}</li>`).join('');
  }

  function resetDraw(){
    winners = []; activePool = participants.slice(); renderWinners(); renderEntries(); setStatus('Reset complete.');
    lidEl.classList.remove('lid-fly');
  }

  async function primeAudio(){
    // Attempt to unlock audio on user intent
    try {
      drum.volume = 0; await drum.play(); drum.pause(); drum.currentTime = 0; drum.volume = 0.9;
      pop.volume = 0; await pop.play(); pop.pause(); pop.currentTime = 0; pop.volume = 0.7;
      setStatus('Sound enabled.');
    } catch(e){ setStatus('Your browser blocked autoplay. Sounds will play after interactions.', true); }
  }

  // ---- Wire up ----
  document.getElementById('btnRefresh').addEventListener('click', refreshParticipants);
  document.getElementById('btnStart').addEventListener('click', startDraw);
  document.getElementById('btnReset').addEventListener('click', resetDraw);
  document.getElementById('autoRefresh').addEventListener('change', toggleAuto);
  document.getElementById('btnSound').addEventListener('click', primeAudio);

  // Initial load
  refreshParticipants();
})();
</script>
</body>
</html>
